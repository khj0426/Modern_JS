# 5장

## 값

평가란 식을 해석해서 값을 생성하거나 참조하는 것을 의미한다.

**값**은 **식**이 **평가**되어 나온 **결과**를 의미한다.

```jsx
10 + 20;
//10 + 20이라는 식은 평가되어 30이라는 결과값을 생성한다.
```

모든 값은 메모리에 2진수 형태로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 

예를들어) 01110001을 숫자로 해석하면 65이고, 문자로 해석하면 ‘A’이다.

 

변수는 하나의 값을 저장하기위해  확보한 메모리 공간 자체 또는, 메모리 공간을 식별하기 위해 붙은 이름이라고 했다. 따라서, 변수에 할당하는 것은 값이다.

```jsx
var sum = 10 + 20;
//변수에는 10 + 20이라는 식이 평가되어 나온 값 30이 할당된다.
```

위의 예제에서 sum변수에 할당되는 것은 10 + 20이 아니라,

10 + 20이 평가되어 나온 값 30이 할당된다. 즉 변수 sum이 기억하는 메모리 공간에 저장된 것은 30이다.

---

### 리터럴

**리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기법이다.**

```jsx
3//숫자리터럴 3
```

위 예제의 3은 단순한 아라비아 숫자같지만 그렇지 않다. 사람이 이해할 수 있는 아라비아 숫자를 사용해 숫자 리터럴 3을 코드에 기술하면 자바스크립트 엔진은 이를 해석해, 값을 생성한다.

**자바스크립트 엔진**은 **코드가 실행되는 시점**인 **런타임**에 **리터럴을 평가해 생성**한다.

즉, 리터럴은 값을 생성하기 위해 미리 약속한 표기법이다.

```jsx
//다양한 종류의 리터럴

//정수 리터럴
100

//부동소수점 리터럴
10.5

//2진수 리터럴
0b01000001 //0b로 시작

//8진수 리터럴
0o101 //0o로 시작

//16진수 리터럴
0X41 //0X로 시작

//문자열 리터럴
'Hello'
"World"

//불리언 리터럴
true
false

//null 리터럴
null

//undefined리터럴
undefined

//객체 리터럴
{ name : 'Lee', address:'Seoul' }

//배열 리터럴
[1,2,3]

//함수 리터럴
function() {}

//정규 표현식 리터럴
/[A-Z] + /g
```

---

### 표현식

**표현식은 값으로 평가될 수 있는 문이다. 즉, 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.**

앞서 살펴본 리터럴을 보자.

```jsx
var score = 100;

```

위 예제의 100은 리터럴이다. 리터럴 100은 자바스크립트 엔진에 의해 평가되어 값을 생성하므로, **리터럴**은 **표현식**이다.

```jsx
var score = 50 + 50;
```

위의 코드는 리터럴과 연산자 (50, + )로 이루어져 있다.

하지만 50 + 50도 평가되어 값(100)을 생성하므로 표현식이다.

앞서 표현식은 **기존 값을 참조할 수 있다**고 했다. score변수를 참조해보자.

```jsx
score; //-100
```

**변수 식별자를 참조**하면 **변수 값으로 평가된다**.

**식별자 참조**는 **값을 생성하지는 않지만**, **값으로 평가**되므로 표현식이다.

표현식은 이처럼 다양한 형태의 조합으로 이루어질 수 있다.

즉, **값으로 평가될 수 있는 모든 문은 표현식**이다.

```jsx
//리터럴 표현식
10
'hello';

//식별자 표현식(이미 식별자가 존재한다고 가정함)

sum
person.name
arr[1]

//연산자 표현식(연산자와 리터럴,연산자와 식별자의 조합도 평가되어 값을 생성한다.)
//표현식이라고 할 수 있음

10+20
sum = 10
sum != 10

//함수 / 메서드 호출 표현식(선언이 이미 존재한다고 가정)
square();
person.getName();

```

표현식은 값으로 평가된다. 

이떄, 표현식과 표현식이 평가된 값은 동등한 관계이다.

ex)

1+2 = 3에서 1+2와 3은 동일하므로

자바스크립트 표현식 1+2는 평가되어 값 3을 생성하므로 표현식 1+2와 평가된 값 3은 동일하다.

```jsx
var x = 1+2;

//식별자 표현식 x는 3으로 평가된다.
x+3//6
```

위의 x+3은 표현식이다. + 연산자는 좌항과 우항의 값을 계산하는 연산자이므로, 

좌항과 우항은 숫자가 위치해야 한다. 이때 좌항 x는 식별자 표현식이다.

x는 할당되어 있는 숫자 값 3으로 평가된다.

---

### 문

**문**(statement)과 **표현식**(expression)이라는 용어를 구분해보자.

**문**은 프로그램을 구성하는 기본 단위이자 **최소 실행 단위**이다.

문은 여러 토큰으로 이루어져있다. **토큰**이란 문법적으로 더 **나눌 수 없는** 기본 요소이다.

예를들어, 키워드,식별자,연산자,리터럴,;,/등의 특수 기호는 문법적으로 나눌 수 없으므로 토큰이다.

**문**을 **명령문**이라고도 한다. 문은 반복문,조건문,할당문,선언문 등으로 구분 할 수 있다.

변수 선언문을 실행하면 변수가 생성되고, 할당문을 실행하면 값이 할당된다.

```jsx
//변수 선언문
var x = 10;

//할당문
x = 5;

//함수 선언문
function foo(){}

//조건문
if(x>1){
console.log(x);
}

//반복문
for(var i = 0;i<5;i++){
	
}
```

---

### 표현식인 문과 표현식이 아닌 문

표현식은 문의 일부일 수도 있고, 그 자체로 문일 수도 있다.

```jsx
//변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다

var x;

//1,2,1+2,x = 1+2는 표현식이다
/* 리터럴표현식, 리터럴표현식, 리터럴과 연산자의 조합(표현식), 
식별자 표현식 x는 3으로 평가된다(표현식) */
```

**표현식인 문과 표현식이 아닌 문?? →**

**표현식인 문**은 표현식으로 **평가될 수 있는 문**이고, **표현식이 아닌 문**은 표현식으로 **평가될 수 없는** 문이다.

예를 들어) 변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다.

하지만 할당문은 값으로 평가될 수 있다. 그래서 표현식인 문이다.

# 👀

### 표현식인 문과 표현식이 아닌 문을 구별하는 방법? →

**변수에 할당해보자!** 

표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다.

하지만 표현식이 아닌 문은 값으로 평가되지 않아서 변수에 할당하면 에러가 발생한다.

```jsx
var foo = var x;
//SyntaxError:Unexpected token var

//var x가 만약 표현식인 문이라면, 변수 foo에 값으로서 할당되어야한다.
//하지만 var x는 값으로 평가될 수 없는, 표현식이 아닌 문이므로, 변수에 할당시 오류발생
```

변수 할당문은 표현식인 문이므로, 변수에 할당 가능하다.

```jsx
var x;
x = 100;

//x = 100그 자체가 표현식이다.
```

**완료 값**

크롬 개발자도구에서 표현식이 아닌 문을 실행하면 언제나 **undefined**를 출력한다.