# 13장-스코프

함수의 매개변수는 함수 몸체 내에서만 참조 가능하고, 함수 밖에서 참조할 수 없다고 했다.

이는 매개변수의 유효범위가, 즉 매개변수의 스코프가 함수 몸체 내로 한정되어있기 때문이다.

```jsx
function add(x,y){
//매개변수는 함수 몸체 내부에서 참조 가능
//매개변수의 스코프는 함수 몸체 내이다.

console.log(x,y); //2 5
return x + y;
}
add(2,5);

console.log(x,y); //ReferenceError
```

변수는 함수 안에서, 코드 가장 바깥영역이나 코드 영역에서도 선언 가능하다.

이떄 코드 블록이나 함수는 중첩 가능하다.

```jsx
var var1 = 1; //코드의 가장 바깥 부분
if(true){
  var var2 = 2; //코드 블록 내에서 선언한 변수
  if(true){
    var var3 = 3; //중첩된 코드 블록 내에서 선언한 변수
  }
}

function foo(){
  var var4 = 4; //함수 내에서 선언한 변수
  
  function bar(){
    var var5 = 5; //중첩된 함수 내에서 선언한 변수
  }
}

console.log(var1); //1
console.log(var2); //2
console.log(var3); //3
console.log(var4); //ReferenceError
console.log(var5); //ReferenceError
```

변수는 **자신이 선언된 위치**에 따라, **자신이 유효한 범위**, 즉 **다른 코드가 자신을 참조할 수 있는 범위**가 달라지게 된다. 

변수가 아니라 모든 식별자가 마찬가지다.

즉, 모든 식별자는 **자신이 선언된 위치**에 의해, **다른 코드가 자신을 참조할 수 있는 유효범위**가 달라진다.

이것을 **스코프**라고 한다. 즉 **스코프**는 **식별자가 유효한 범위**이다.

```jsx
var x = 'global';

function foo(){
  var x = 'local';
  console.log(x); //1-'local'
}

foo(); 
console.log(x); //2- 'global'
```

코드의 가장 바깥영역과 foo 함수 내부에 같은 이름을 갖는 x변수를 선언했고,

1과 2에서 각각 변수를 참조한다.

이떄, 자바스크립트 엔진은 이름이 같은 두 개의 변수 중에 어느 것을 참조할지 결정해야한다.

이것을 **식별자 결정** 이라고 부른다.

자바스크립트는 스코프를 통해 어떤 변수를 참조할지 결정한다.

**스코프**는 따라서 **자바스크립트 엔진이 식별자를 검색할 떄 사용하는 규칙**이라고도 할 수 있다.

---

**렉시컬 환경**

**렉시컬 환경**은 코드 블록, 함수, script를 실행하기 전에 앞서 생성되는 특별한 객체이다.

**실행할 스코프 범위 안에 있는 변수와 함수**를 프로퍼티로 저장하는 객체이다.

렉시컬 환경은 크게 2가지로 구성된다.

1️⃣ 환경 레코드 (모든 변수들을 프로퍼티로 갖는 객체이다.)

2️⃣ 외부 코드와 연관된 외부 렉시컬 환경에 대한 참조

---

**실행 컨텍스트**

자바스크립트 엔진은 코드를 실행하기 위해 실행에 필요한 여러 정보를 알아야 한다.

ex_) 변수(전역변수,매개변수)와 변수의 유효범위, this..등

[https://khj0426.tistory.com/75](https://khj0426.tistory.com/75)

**실행 컨텍스트란 코드가 실행되기 위해 필요한 정보들을 가진 범위를 추상화하기 위해 객체 형태로 나타낸 것이다.**

---

위 코드의 가장 바깥영역에 선언한 x는 코드 어디에서든 참조 가능하다.

하지만 foo 함수 내의 x변수는 foo 함수 내부에서만 참조 가능하고, foo 함수 외부에서는 참조 불가능하다.

두 개의 x변수는 식별자 이름이 동일하지만, 변수의 유효범위,스코프가 다르다.

![Untitled](13%E1%84%8C%E1%85%A1%E1%86%BC-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3%2002f585cca8d145df9e207903a56522fa/Untitled.png)

식별자는 유일해야 하고,변수 이름의 중복이 불가능하다. 

하나의 값은 유일한 식별자에 연결 되어야 한다.

즉 스코프 내에서 식별자는 유일해야 하지만, 다른 스코프에서는 같은 이름의 식별자도 사용 가능하다.

var 키워드로 선언한 변수는같은 스코프 내의 변수의 중복 선언을 허용한다. 이는 의도치 않게 변수의 값이 재할당될 수 있다. let키워드와 const 키워드는 변수의 중복 선언을 허용하지 않는다.

```jsx
function foo(){
  var x = 1;
  var x = 2;
  console.log(x); //2
}

function bar(){
  let x = 3;
  let x = 2;
}
//SyntaxError
bar();
```

---

### **스코프의 종류**

코드는 전역과 지역으로 구분 가능하다.

| 구분 | 설명 | 스코프 | 변수 |
| --- | --- | --- | --- |
| 전역 | 코드의 가장 바깥 영역 | 전역 스코프 | 전역 변수 |
| 지역 | 함수 몸체 내부 | 지역 스코프 | 지역 변수 |

변수는 자신이 선언된 위치(지역)에 따라 자신이 유효한 범위인 스코프가 결정된다.

전역에서 선언된 변수는 전역스코프롤, 지역에서 선언된 변수는 지역 스코프를 갖는다.

![Untitled](13%E1%84%8C%E1%85%A1%E1%86%BC-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3%2002f585cca8d145df9e207903a56522fa/Untitled%201.png)

전역이란 코드의 가장 바깥 부분을 말한다.

전역은 전역 스코프를 갖는다. 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 된다.

**전역 변수는 어디서든 참조 가능하다**

위 코드에서 코드 가장 바깥 영역에서 선언한 변수 x,y는 전역 변수이다.

---

### 지역과 지역 스코프

지역이란 **함수 몸체 내부**를 의미한다. 지역은 지역 스코프를 갖는다. 지역에 변수를 선언시

지역 스코프를 갖는 지역 변수가 된다.

지역변수는 **자신이 선언된 지역과 하위 지역(중첩함수) 안에서만 참조할 수 있다**.

즉, 지역변수는 **자신의 지역 스코프와 하위 지역 스코프에서 유효하다.**

위 예제의 outer 함수안에서 선언한 변수 z는 지역변수이다. 

변수 z는 자신의 지역 스코프인 outer함수의 스코프와, 하위 지역 스코프인 (중첩함수)

inner에서 유효하다.

하지만 z를 전역에서 참조하면 오류가 난다.

inner함수안에서 선언한 x도 지역변수이다.

변수 x는 자신의 지역 스코프인 inner 내부에서만 참조할 수 있다.

지역변수 x를 inner함수 외부나 전역에서 참조하면 오류가 난다.

그런데 지역변수 x 외의 전역변수 x가 존재한다.

이떄 inner함수 내부에서 x변수를 참조하면 전역변수 x가 참조되는 것이 아니라,

지역 변수 x가 참조된다.

이는 JS엔진이 **스코프 체인을 통해 참조할 변수를 검색했기 떄문이다**

---

### **스코프체인**

함수는 전역에서, 또는 함수 몸체 안에서 (지역,중첩된 함수) 정의할 수 있다.

함수는 중첩 가능하므로, 지역 스코프도 중첩이 가능하다.

**스코프는 함수의 중첩에 의해 계층적 구조를 갖는다**

중첩 함수의 지역 스코프는 중첩 함수를 포함하는 함수의 지역스코프와 계층적이다.

이떄 중첩 함수를 포함하는 함수의 지역 스코프를 상위 스코프라 부른다.

위 예제의 지역은 outer와 outer안의 함수 inner가 있다.

inner함수는 outer함수의 중첩 함수이다. 즉, inner함수의 상위 스코프는 outer함수의 지역스코프다.

그리고 outer함수의 상위 스코프는 제일 최상단의 스코프인 전역 스코프이다.

![Untitled](13%E1%84%8C%E1%85%A1%E1%86%BC-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3%2002f585cca8d145df9e207903a56522fa/Untitled%202.png)

모든 스코프는 하나의 계층 구조를 가지며, 모든 스코프의 최상단에는 전역 스코프가 존재한다.

이렇게 스코프가 **계층적으로 연결된 것**을 **스코프 체인**이라 한다.

변수를 참조할 떄, 자바스크립트 엔진은 스코프 체인을 통해 변수를 검색한다.

이떄, 변수를 참조하려는 코드의 스코프에서 시작해서 **상위 스코프 방향**으로 변수를 찾아나간다.

**상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조 가능하지만,**

**하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다**

---

### 함수 레벨 스코프

지역은 함수 몸체 안에서이고, 지역은 지역 스코프를 만든다고 했다.

이는 **코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성**된다는 것을 의미한다.

**var키워드로 선언된 변수는 오직 함수의 코드 블록을 지역 스코프로 인정한다.**

이러한 특징을 **함수 레벨 스코프**라 한다.

```jsx
var x = 1;
if(true){
  var x = 10;
}
console.log(x);  //10
```

전역변수 x가 선언되었고 if 안에도 x가 선언되었다.

이떄 if문의  코드 블록에서 선언된 x는 **전역 변수**다.

var키워드로 선언한 변수는 오직 함수의 몸체만을 지역 스코프로 인정하기 떄문에,

if,for,while등… **함수 밖에서 선언한 변수는 모두 전역 변수**다.

**var키워드로 선언된 변수는 오직 함수의 몸체만을 지역 스코프로 인정하지만,**

**let,const키워드는 블록 레벨 스코프를 지원한다.**

---

### 렉시컬 스코프

```jsx
var x = 1;

function foo(){
	var x = 10;
  bar();
}

function bar(){
  console.log(x);
}

foo(); //1
bar(); //1
```

**렉시컬 스코프는 함수를 어디에 선언하였는지에 따라 결정된다**

foo()함수와 bar()함수는 중첩되지 않았고 ,전역에 함수를 선언했다.

foo()함수와 bar()함수의 상위 스코프는 전역 스코프이다.

foo()호출 시 bar함수가 실행된다.

bar함수는 x를 출력하는데, 이떄 bar함수의 지역스코프에 지역 변수 x가 존재하지 않으므로, 

자신의 상위 스코프인 전역 스코프에서 전역 변수 x를 찾는다.

전역 스코프에 x가 존재하므로 1으로 출력한다

---

### 네임스페이스

```
네임스페이스는 프로그램에서 필요로 하는 전역 변수의 개수를 줄이는 동시에 과도한 접두어를 사용하지 않고도 이름이 겹치지 않게 해줍니다.
```

출처:

[https://webclub.tistory.com/311](https://webclub.tistory.com/311)

[Web Club:티스토리]

네임스페이스란 구분이 가능하도록 정해놓은 범위,영역이다.

말 그대로, 이름 공간을 선언해, 다른 공간과 구분하는 것이다.

### 네임스페이스 패턴

전역 유효 범위 안에 수많은 함수, 객체 , 변수들로 어지럽히지 않도록 하기 위해, 전역 객체를 만들고 모든 기능을 이 객체에 추가하는 패턴을 말한다.

[https://www.nextree.co.kr/p7650/](https://www.nextree.co.kr/p7650/)

![Untitled](13%E1%84%8C%E1%85%A1%E1%86%BC-%E1%84%89%E1%85%B3%E1%84%8F%E1%85%A9%E1%84%91%E1%85%B3%2002f585cca8d145df9e207903a56522fa/Untitled%203.png)

수정 전 코드

```jsx
//생성자 함수 2개

function parent(){
    
}

function child(){
    
}

//변수 1개
var x = 1;

//객체 2개

var module = {};
modulde.data = {
    a:1,
    b:2
};

var module2 = {};
```

→ 위의 코드를 다시 좋은 방향으로 짜보자면, 애플리케이션 전용 객체를 만든다 (ex myapp)

그런 다음 모든 함수와 변수를 이 객체의 프로퍼티로 설정한다.

수정 후 코드

```jsx
//전역 객체
var myapp = {};

//생성자 
myapp.parent = function(){};
myapp.child = function(){};

//변수
myapp.x = 1;

//객체 컨테이너
myapp.modules = {};

myapp.modeles.module1 = {};
myapp.modules.modulel.data = {a:1,b:2};
myapp.modules.module2 = {};
```

전역 네임스페이스의 이름은 한눈에 알아보기 쉽게 회사이름, 라이브러리 이름 등등 이 있을 수 있다.

전역 객체 이름은 모두 대문자로 사용하는 규칙을 쓰기도 한다